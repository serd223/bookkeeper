# bookkeeper
`bookkeeper` is a single source file C code generation tool that generates boilerplate serialization/deserialization code for your user defined structures.

`bookkeeper` is heavily inspired by the Rust [`serde`](https://serde.rs/) crate and [this Tsoding stream](https://youtu.be/hnM6aSpWJ8c?si=7WqJW0dy8oaJtdmm).

# Quick Start
Here is a simple example that outputs both JSON and Debug output: ([quick.c](https://github.com/serd223/bookkeeper/blob/master/examples/quick.c))
```c
#include <stdio.h>

#define BK_IMPLEMENTATION
#define BK_DISABLE_json_PARSE

#include "people.h" // Example file
#include "people.h.bk.h" // Generated file

typedef struct {
    Person friend_info;
    int years_known;
} Friend derive_json() derive_debug();
#include "quick.c.bk.h" // Generated file

int main(void) {
    Person p = {.name = "Alice", .age = 30, .married = false};
    Friend f = {.friend_info = p,.years_known = 5};
    printf("JSON:\n");
    dump_json_Friend(&f, stdout);
    printf("\n\nDebug:\n");
    dump_debug_Friend(&f, stdout);
    return 0;
}
```
Here is its output:
```
JSON:
{"friend_info":{"name":"Alice","age":30,"married":false},"years_known":5}

Debug:
Friend {
    friend_info: Person {
        (string) name: Alice
        (int) age: 30
        (bool) married: false
    }
    (int) years_known: 5
}
```
And this is how you can build it:
```console
    $ git clone https://github.com/serd223/bookkeeper.git && cd bookkeeper
    $ mkdir build && mkdir gen
    $ make quick
    $ ./build/quick
```

# But why?
As C programmers we find ourselves constantly writing boilerplate code for parsing some config struct, or just simply printing any struct. C lacks the necessary metaprogramming tools to automate the generation of this kind of boilerplate code (unlike more modern languages where you can do `#derive(Debug)` or `deriving Show`). So we either use code generation tools like `bookkeeper` to generate this code, or write it by hand every. single. time. `bookkeeper` aims to be an easy to use, extendible, user friendly, embedded friendly and portable solution to this problem.

>[!WARNING]
> Although bookkeeper aims to be all of those things, it is still somewhat early in development and the tool itself only supports Linux. The generated code is mostly embedded friendly and portable, though.

# Table of Contents
This README contains both basic examples and general documentation for `bookkeeper` and thus is admittedly somewhat lengthy, so you can use this Table of Contents to jump to sections that may interest you (Though it is recommended to at least read the 'Overview' section).
  * [Overview](https://github.com/serd223/bookkeeper?tab=readme-ov-file#overview)
  * [Configuration](https://github.com/serd223/bookkeeper?tab=readme-ov-file#configuration)
  * [Schema Extensions](https://github.com/serd223/bookkeeper?tab=readme-ov-file#schema-extensions)
  * [Including `bookkeeper` in your project](https://github.com/serd223/bookkeeper?tab=readme-ov-file#including-bookkeeper-in-your-project)
  * [Build Instructions](https://github.com/serd223/bookkeeper?tab=readme-ov-file#build-instructions)

# Overview
The `bk` tool requires an output directory and (optional) input file(s). The output directory can be specified with `-o`. Then you can either supply files one by one with the `-i` flag (like `-i file1 -i file`), or you can supply an input directory with `-I` and the tool will scan that directory for any `.c` or `.h` files. `bk` analyzes the included files and collects all `typedef struct { field_type field; } StructName` style struct definitions. Each struct can 'derive' functionalities that will be included in the generated code. For instance, if you want your struct to support JSON parsing/dumping you would write:

```c
typedef struct {
    int some_field;
    const char* some_other_field;
} StructName derive_json();
```
(See [people.h](https://github.com/serd223/bookkeeper/blob/master/examples/people.h))

`derive_$schema$` attributes are macros that are included inside the `output-directory/derives.h` file generated by `bk`. So, to use the 'derive' functionality you will need to run `bk` once to actually acquire the base `derives.h` file that includes the `derive_$schema$` definitions. Running `bk` only with an `output-directory` and no input files will only generate `derives.h`. `bk` generates separate files for each analyzed file, generated files' names follow the format of `input_file_name.bk.h`, these files are [stb-style header only libraries](https://github.com/nothings/stb?tab=readme-ov-file#faq) that include the declarations and implementations of the generated functions for your structs (implementations included with `#define BK_IMPLEMENTATION`). Generated functions look like this:
```c
void dump_$schema$_$type$($type$* item, void* dst) {
    /* generated impl */
}

// returns zero if an error happens, otherwise returns 1
int parse_$schema$_$type$(char* src, unsigned long len, $type$* dst) {
    /* generated impl */
}
```
Depending on the `output-mode`, generated files are either placed next to their 'source' files (`mirror` mode), or inside `output-directory` (`dir` mode). The `derives.h` file is always placed inside `output-directory` regardless of `output-mode`.

The behavior of generated code can be tweaked with defining/redefining certain macros while including them. Although the specific names of these macros can be customized, here are some of them explained with their default names:
  * Dump functions use a macro named `BK_FMT` defined inside the `*.bk.h` files to output into the provided `dst` buffer.
  * The type of this `dst` argument for the 'dump' family of functions depends on the `BK_FMT_DST_t` macro that you should redefine if your `BK_FMT` implementation expects a different type from the default one. The default implementation uses `fprintf` and expects `dst` to be `FILE*` but it can be redefined inside your code before including your `*.bk.h` file. (See [dump_people.c](https://github.com/serd223/bookkeeper/blob/master/examples/dump_people.c))
  * There are also disable macros generated for each type, these macros have a prefix `disable-prefix` which defaults to `BK_DISABLE_`. The following examples will be shown with the default prefix:
    - `BK_DISABLE_DUMP`: Disables dump functionality.
    - `BK_DISABLE_PARSE`: Disables parse functionality.
    - `BK_DISABLE_$type$`: Disables all functionality that belongs to $type$.
    - `BK_DISABLE_$type$_DUMP`: Disables dump functionality that belongs to $type$.
    - `BK_DISABLE_$type$_PARSE`: Disables parse functionality that belongs to $type$.
    - `BK_DISABLE_$type$_$schema$`: Disables all functionality that works on $schema$ and belongs to $type$.
    - `BK_DISABLE_$type$_$schema$_DUMP`: Disables dump functionality that works on $schema$ and belongs to $type$.
    - `BK_DISABLE_$type$_$schema$_PARSE`: Disables parse functionality that works on $schema$ and belongs to $type$.
    - `BK_DISABLE_$schema$`: Disables all functionality that works on $schema$.
    - `BK_DISABLE_$schema$_DUMP`: Disables dump functionality that works on $schema$.
    - `BK_DISABLE_$schema$_PARSE`: Disables parse functionality that works on $schema$.
  * You can also use the `--disabled` flag with `bk` to make all functionality disabled by default. In this mode, you can use the same macros listed above with the `enable-prefix` instead of `disable-prefix`. `enable-prefix` defaults to `BK_ENABLE_`

The names of the special generated macros mentioned above (like `BK_FMT`) can all be customized via command line arguments supplied to `bk`. Try `bk -h` for a list of all available flags.

`bookkeeper` supports user-defined schemas via the schema extension system. See the [Schema Extensions section](https://github.com/serd223/bookkeeper/tree/master?tab=readme-ov-file#schema-extensions) and the [schema extension example](https://github.com/serd223/bookkeeper/blob/master/examples/bk_ext.c).

## Watch mode
You can use the `-w` flag to start `bk` in 'watch mode' where instead of analyzing files and exiting immediately, it will keep running and re-analyze files when they are modified.

>[!WARNING]
> This feature is still work in progress and currently uses too much CPU. There currently exists a customizable `watch-delay` to combat this problem but it is more of a band-aid solution

# Configuration
The generated code and the behavior of `bk` can be tweaked using a configuration file or via command line arguments. For a full list of command line options, you can run `bk -h`.

`bk` looks for a file named `.bk.conf` in the current working directory by default. This file is optional and parsing a config file is skipped if it doesn't exist. Alternatively, you can supply a custom path for your config file with `bk --config-path path/to/your/file`. If a custom config path is supplied and that file cannot be found/read, `bk` reports an error and exits.

A valid config file looks like this:
```ini
# Comments start with #
key=value
key1=othervalue
```
Values can be integers, floats, strings, or booleans (denoted with `true` and `false`).

Since command line flags and config options are mostly the same, you can run `bk -h` to see descriptions that explain what each key means.

A notable exception to this is `include-files` vs `-i`. `-i` accepts a single file and you supply multiple `-i` flags when you want to include multiple files. On the other hand, the `include-files` option accepts a comma separated list of files (like 'file1,file2,file3').

When in doubt, see [full_config.conf](https://github.com/serd223/bookkeeper/blob/master/examples/full_config.conf) for a list of all valid keys.

Note that configuration files are processed _before_ command line arguments. This means that any command line argument will override the configuration file if they change the same option.

# Schema Extensions
In order to add an extension to `bookkeeper`, you will need to wrap the `bk.c` file in your custom wrapper. You will need the `bk_ext.h` header to have access to the necessary types in your wrapper. A simple wrapper would look like this:
(See [examples/bk_ext.c](https://github.com/serd223/bookkeeper/blob/master/examples/bk_ext.c) for a full example)
```c
    #include "bk_ext.h"
    // Common includes you probably will need in extensions
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>

    size_t gen_example_dump_decl(String* book_buf, CCompound* ty, const char* dst_type) { /* impl */ }
    size_t gen_example_parse_decl(String* book_buf, CCompound* ty) { /* impl */ }
    void gen_example_dump_impl(String* book_buf, CCompound* ty, const char* dst_type, const char* fmt_macro) { /* impl */ }
    void gen_example_parse_impl(String* book_buf, CCompound* ty) { /* impl */ }

    // The `name` field should be unique among other schemas for
    // macros that mention schemas to work properly
    #define BK_ADD_SCHEMAS(s)\
    Schema example = {\
        .gen_dump_decl = gen_example_dump_decl,\
        .gen_parse_decl = gen_example_parse_decl,\
        .gen_dump_impl = gen_example_dump_impl,\
        .gen_parse_impl = gen_example_parse_impl,\
        .derive_attr = "derive_example",\
        .name = "example"\
    };\
    push_da(&s, example);
    // This file should be able to find `stb_c_lexer.h` since it is included by `bk.c`
    #include "bk.c"
```

In order to test the provided extension example, you can run:
```console
    $ make schema_ext
    $ ./build/bk_ext -I ./examples -o ./gen -om dir
```
You can then inspect the generated files inside the `gen` folder to see the generated example schema functions.

# Including `bookkeeper` In Your Project
You _can_ just tell people to put the `bk` executable in their `PATH` while compiling your project but it is probably better to just include the source code of `bk` in your project and build it during your build process. This is pretty easy since the entire source code of the tool is inside [`bk.c`](https://github.com/serd223/bookkeeper/blob/master/bk.c) (This source file also includes its license inside so you don't have to worry about that). The only caveat with this approach is that you also have to include [`stb_c_lexer`](https://github.com/nothings/stb/blob/master/stb_c_lexer.h) in your project but that is a pretty lightweight single file dependency, as well.

You can build `bk.c` however you like as long as it can find `stb_c_lexer.h`. For instructions on how to build the contents of _this repository_, see the [Build Instructions section](https://github.com/serd223/bookkeeper/tree/master?tab=readme-ov-file#build-instructions).

## Dependencies of generated code
Here is a list of dependencies the **generated code** may depend on:
### parse_json_*
 - These functions depend on the [cJSON](https://github.com/DaveGamble/cJSON) library to parse JSON. Users are expected to have already included this library before including generated code. (See [parse_people.c](https://github.com/serd223/bookkeeper/blob/master/examples/parse_people.c))

# Build Instructions
## Prerequisites
 - [clang](https://releases.llvm.org/download.html)
 - [git](https://git-scm.com/)

## Instructions
First, you will need to clone this repository and `cd` into the repository's root directory:
```console
    $ git clone https://github.com/serd223/bookkeeper.git
    $ cd bookkeeper
```

Then create `build` and `gen` folders:
```console
    $ mkdir build
    $ mkdir gen
```

You can build `bk` by running:
```console
    $ make
    $ ./build/bk
```

## Building Examples
If you want to build the `dump_people` example, run: (auto-generates necessary files)
```console
    $ make dump
    $ ./build/dump_people
```

If you want to build the `parse_people` example, run: (auto-generates necessary files)
```console
    $ make parse
    $ ./build/parse_people
```

